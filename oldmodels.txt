# from django.db import models
# from django.core.validators import MinValueValidator
# from django.core.exceptions import ValidationError
# from django.utils.timezone import now

# class Category(models.Model):
#     cname=models.CharField(max_length=100, unique=True)

# class Location(models.Model):
#     loc=models.CharField(max_length=35, unique=True)
#     area_code=models.IntegerField(max_length=10)

# class Supplier(models.Model):
#     name = models.CharField(max_length=255)
#     contact_info = models.CharField(max_length=255)
#     address = models.CharField(max_length=500)

# class Customer(models.Model):
#     name = models.CharField(max_length=255)
#     contact_info = models.CharField(max_length=255)
#     address = models.CharField(max_length=500)
#     email = models.EmailField()

# class Item(models.Model):
#     name = models.CharField(max_length=100, unique=True)
#     category = models.ForeignKey(Category, on_delete=models.CASCADE)
#     loc = models.ForeignKey(Location, on_delete=models.CASCADE)
#     # Customer_ID = models.ForeignKey(Customer, on_delete=models.CASCADE)
#     # Supplier_ID = models.ForeignKey(Supplier, on_delete=models.CASCADE)
#     quantity = models.IntegerField(validators=[MinValueValidator(0)])
#     price = models.DecimalField(max_digits=10, decimal_places=2, validators=[MinValueValidator(0)])
#     description = models.TextField(blank=True, null=True)
#     created_at = models.DateTimeField(default=now, editable=False)
#     updated_at = models.DateTimeField(auto_now=True)

#     def formatted_created_at(self):
#         return self.created_at.strftime('%Y-%m-%d %H:%M:%S')  # Format as YYYY-MM-DD HH:MM:SS

#     def formatted_updated_at(self):
#         return self.updated_at.strftime('%Y-%m-%d %H:%M:%S')  # Format as YYYY-MM-DD HH:MM:SS

#     def __str__(self):
#         return self.name
# class Transaction(models.Model):
#     ITEM_CHOICES = [
#         ('IN', 'Inbound'),
#         ('OUT', 'Outbound')
#     ]
    
#     TRANSACTION_CATEGORY_IN = [
#         ('PS', 'Purchased from Supplier'),
#         ('PI', 'Produced In-house')
#     ]
    
#     TRANSACTION_CATEGORY_OUT = [
#         ('SC', 'Sold to Customer'),
#         ('GD', 'Goods Damaged')
#     ]
    
#     item = models.ForeignKey('Item', on_delete=models.CASCADE)  # Relates to the Item model
#     transaction_type = models.CharField(
#         max_length=10, 
#         choices=ITEM_CHOICES,
#     )
    
#     transaction_category = models.CharField(
#         max_length=10,
#         choices=[],  # Initially empty, to be set dynamically
#     )
    
#     supplier_id = models.ForeignKey('Supplier', null=True, blank=True, on_delete=models.SET_NULL)
#     customer_id = models.ForeignKey('Customer', null=True, blank=True, on_delete=models.SET_NULL)
    
#     quantity = models.PositiveIntegerField()
#     transdate = models.DateTimeField(auto_now_add=True)

#     def clean(self):
#         # Dynamically set transaction category choices based on transaction_type
#         if self.transaction_type == 'IN':
#             self.transaction_category.choices = self.TRANSACTION_CATEGORY_IN
#         elif self.transaction_type == 'OUT':
#             self.transaction_category.choices = self.TRANSACTION_CATEGORY_OUT
#         else:
#             raise ValidationError("Invalid transaction type.")

#         # Validate that supplier_id or customer_id is filled based on the category
#         if self.transaction_category == 'PS' and not self.supplier_id:
#             raise ValidationError("Supplier ID must be provided for 'Purchased from Supplier'.")
        
#         if self.transaction_category == 'SC' and not self.customer_id:
#             raise ValidationError("Customer ID must be provided for 'Sold to Customer'.")
        
#         super().clean()

    
#     def formatted_transdate(self):
#         return self.transdatestrftime('%Y-%m-%d %H:%M:%S') # Format as YYYY-MM-DD HH:MM:SS

#     def save(self, *args, **kwargs):
#         # Make sure to validate the model before saving
#         self.full_clean()
#         super().save(*args, **kwargs)

#     def __str__(self):
#         return f"{self.transaction_type} - {self.item.name} - {self.transaction_category}"